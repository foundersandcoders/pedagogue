import { error, json } from '@sveltejs/kit';
import { env } from '$env/dynamic/private';
import type { RequestHandler } from './$types';
import { ChatAnthropic } from '@langchain/anthropic';
import { HumanMessage, SystemMessage } from '@langchain/core/messages';
import { getSchemaRequirements } from '$lib/schemas/schemaTemplate.js';
import { cleanXML } from '$lib/schemas/xmlUtils.js';
import { validateModuleXML } from '$lib/schemas/moduleValidator.js';

/**
 * Extract text content from Claude's response
 * When web search is used, response.content is an array of blocks including citations
 * This function extracts only the text blocks and concatenates them
 */
function extractTextContent(content: any): string {
	if (typeof content === 'string') {
		return content;
	}

	if (Array.isArray(content)) {
		// Filter for text blocks only, ignoring citations and other metadata
		return content
			.filter(block => block.type === 'text')
			.map(block => block.text)
			.join('');
	}

	// Fallback for unexpected formats
	return String(content);
}

/**
 * Extract XML module specification from Claude's response
 * Handles cases where Claude includes explanation text before/after the XML
 * Strips comments and ensures proper formatting
 */
function extractModuleXML(content: string): string | null {
	// Try to find XML content between <Module> tags (capital M)
	const xmlMatch = content.match(/<Module>[\s\S]*?<\/Module>/i);
	if (xmlMatch) {
		const rawXML = xmlMatch[0];
		// Clean the XML (remove comments and normalize whitespace)
		const cleanedXML = cleanXML(rawXML);
		return `<?xml version="1.0" encoding="UTF-8"?>\n${cleanedXML}`;
	}

	// If no match, check if the entire content is valid XML
	const trimmed = content.trim();
	if (trimmed.match(/^<Module>/i) && trimmed.match(/<\/Module>$/i)) {
		const cleanedXML = cleanXML(trimmed);
		return `<?xml version="1.0" encoding="UTF-8"?>\n${cleanedXML}`;
	}

	return null;
}

/**
 * API endpoint for generating module content using Claude + LangChain
 * Supports SSE streaming for progress updates during generation
 */

interface GenerateRequest {
	projectsData?: any;
	skillsData?: any;
	researchData?: any;
	structuredInput?: Record<string, any>;
	enableResearch?: boolean;
	useExtendedThinking?: boolean;
}

export const POST: RequestHandler = async ({ request }) => {
	// Validate environment setup
	const apiKey = env.ANTHROPIC_API_KEY;
	if (!apiKey) {
		throw error(500, {
			message: 'ANTHROPIC_API_KEY not configured. Set this in your environment variables.'
		});
	}

	try {
		// Parse incoming request
		const body: GenerateRequest = await request.json();

		// Validate required inputs
		if (!body.projectsData || !body.skillsData || !body.researchData) {
			throw error(400, {
				message: 'Missing required data. projectsData, skillsData, and researchData are all required.'
			});
		}

		// Check if client accepts streaming
		const acceptHeader = request.headers.get('accept');
		const supportsSSE = acceptHeader?.includes('text/event-stream');

		if (supportsSSE) {
			// Return SSE stream for progress updates
			return createSSEStream(body, apiKey);
		} else {
			// Return standard JSON response
			return await generateModule(body, apiKey);
		}

	} catch (err) {
		if (err && typeof err === 'object' && 'status' in err) {
			// Re-throw SvelteKit errors
			throw err;
		}

		console.error('Generation error:', err);
		throw error(500, {
			message: err instanceof Error ? err.message : 'Unknown error during generation'
		});
	}
};

/**
 * Build the generation prompt from input data
 * Includes retry-specific validation errors if this is a retry attempt
 */
function buildGenerationPrompt(body: GenerateRequest, validationErrors?: string[]): string {
	const projectsInfo = JSON.stringify(body.projectsData, null, 2);
	const skillsInfo = JSON.stringify(body.skillsData, null, 2);
	const researchInfo = JSON.stringify(body.researchData, null, 2);
	const structuredInfo = body.structuredInput ? JSON.stringify(body.structuredInput, null, 2) : 'None provided';

	const researchInstructions = body.enableResearch
		? `
RESEARCH INSTRUCTIONS:
You have access to web search to find current, relevant information about:
- Latest best practices and trends for the technologies mentioned
- Current industry standards and tooling
- Recent developments in AI and software development
- Real-world examples and case studies

Use web search to ensure the curriculum is up-to-date and reflects current industry practice.
Focus on reputable sources: vendor documentation, established tech publications, and academic sources.`
		: '';

	const retrySection = validationErrors && validationErrors.length > 0
		? `

⚠️ PREVIOUS ATTEMPT FAILED VALIDATION ⚠️

Your previous response had these validation errors:
${validationErrors.map(err => `- ${err}`).join('\n')}

Please correct ALL of these issues in your next response. Pay special attention to:
- Meeting minimum cardinality requirements (e.g., "at least 3 objectives")
- Including all required sections and subsections
- Using exact tag names (case-sensitive)
- Ensuring proper XML structure with matching opening/closing tags
`
		: '';

	// Get the schema requirements
	const schemaRequirements = getSchemaRequirements();

	return `You are an expert curriculum designer for peer-led AI Engineering courses. Generate a comprehensive module specification based on the provided context.

INPUT DATA:

Project Context:
${projectsInfo}

Additional Skills (e.g., Python):
${skillsInfo}

Research Topics:
${researchInfo}

Structured Input (Context from course council):
${structuredInfo}

Research Enabled: ${body.enableResearch ? 'Yes - Use web search to find current information' : 'No'}
Extended Thinking: ${body.useExtendedThinking ? 'Yes' : 'No'}
${researchInstructions}
${retrySection}

TASK:
Generate a detailed module specification that:
1. Synthesizes the project requirements with additional skills and research topics
2. Maintains the depth and detail level shown in the input examples
3. Creates clear, actionable learning objectives
4. Defines practical project briefs based on the provided examples
5. Includes comprehensive research topics with guidance for learners
6. Provides concrete examples for each project brief (minimum 3)
7. Suggests interesting project twists to add challenge
8. Maintains alignment with peer-led teaching philosophy
${body.enableResearch ? '9. Incorporates current best practices and trends discovered through web research' : ''}

IMPORTANT GUIDELINES:
- Match the level of detail in the input examples
- ProjectBriefs should include Overview, Criteria, Skills, and Examples
- Research topics should include practical guidance for how to research them
- Skills should be granular and specific (e.g., "Package management in Python" not "Coding in Python")
- Examples should be diverse and substantially different from each other
- Project twists should add interesting challenges without being essential

${schemaRequirements}`;
}

/**
 * Reputable domains for AI technology research
 * Note: Some major news sites (BBC, Reuters, The Verge, Wired, Ars Technica)
 * block Anthropic's crawler, so they're excluded from this list
 */
const AI_RESEARCH_DOMAINS = [
	// AI Vendors
	'anthropic.com',
	'claude.ai',
	'openai.com',
	'deepmind.google',
	'ai.google',
	'microsoft.com',
	// Tech News & Analysis
	'techcrunch.com',
	'venturebeat.com',
	'thenextweb.com',
	// Developer Resources
	'github.com',
	'stackoverflow.com',
	'medium.com',
	'dev.to',
	'docs.python.org',
	'python.org',
	// LangChain Docs
	'js.langchain.com',
	'python.langchain.com',
	// Academic & Research
	'arxiv.org',
	'acm.org',
	'ieee.org'
];

/**
 * Create Server-Sent Events stream for real-time progress updates
 * Includes validation and automatic retry logic
 */
function createSSEStream(body: GenerateRequest, apiKey: string) {
	const stream = new ReadableStream({
		async start(controller) {
			const encoder = new TextEncoder();
			const MAX_RETRIES = 3;
			let lastError: string[] = [];

			try {
				// Send initial connection confirmation
				controller.enqueue(
					encoder.encode('data: {"type":"connected","message":"Generation started"}\n\n')
				);

				// Initialize LangChain ChatAnthropic with streaming
				let model = new ChatAnthropic({
					anthropicApiKey: apiKey,
					modelName: 'claude-sonnet-4-5-20250929', // Claude Sonnet 4.5
					temperature: 0.7,
					maxTokens: 16384, // Sonnet 4.5 supports up to 64K output tokens
					timeout: 120000, // 2 minute timeout
					streaming: true
				});

				// Conditionally add web search capability
				if (body.enableResearch) {
					controller.enqueue(
						encoder.encode('data: {"type":"progress","message":"Enabling deep research with web search..."}\n\n')
					);

					model = model.bindTools([{
						type: 'web_search_20250305',
						name: 'web_search',
						max_uses: 5,
						allowed_domains: AI_RESEARCH_DOMAINS
					}]);
				}

				// Retry loop
				for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
					controller.enqueue(
						encoder.encode(`data: ${JSON.stringify({
							type: 'progress',
							message: attempt === 1
								? 'Analyzing input files...'
								: `Retry attempt ${attempt}/${MAX_RETRIES} with refined instructions...`
						})}\n\n`)
					);

					// Build the prompt (include validation errors if retrying)
					const prompt = buildGenerationPrompt(body, attempt > 1 ? lastError : undefined);

					const messages = [
						new SystemMessage('You are an expert curriculum designer. Generate high-quality educational content in valid XML format.'),
						new HumanMessage(prompt)
					];

					controller.enqueue(
						encoder.encode('data: {"type":"progress","message":"Generating module content with Claude..."}\n\n')
					);

					let fullContent = '';

					// Stream the response
					const responseStream = await model.stream(messages);

					for await (const chunk of responseStream) {
						// Extract text content from chunk (handles both string and array formats)
						const textChunk = extractTextContent(chunk.content);

						if (textChunk) {
							fullContent += textChunk;
							// Send chunks of content as they arrive
							const progressData = {
								type: 'content',
								chunk: textChunk,
								message: 'Streaming content...'
							};
							controller.enqueue(
								encoder.encode(`data: ${JSON.stringify(progressData)}\n\n`)
							);
						}
					}

					// Extract and validate XML
					controller.enqueue(
						encoder.encode('data: {"type":"validation_started","message":"Validating generated content..."}\n\n')
					);

					const xmlContent = extractModuleXML(fullContent);

					if (!xmlContent) {
						lastError = ['Failed to extract valid XML from response. Ensure output is wrapped in <Module>...</Module> tags.'];

						controller.enqueue(
							encoder.encode(`data: ${JSON.stringify({
								type: 'validation_failed',
								message: `XML extraction failed (attempt ${attempt}/${MAX_RETRIES})`,
								errors: lastError
							})}\n\n`)
						);

						if (attempt < MAX_RETRIES) {
							continue; // Retry
						} else {
							// All retries exhausted
							controller.enqueue(
								encoder.encode(`data: ${JSON.stringify({
									type: 'error',
									message: 'Failed to generate valid XML after all retry attempts',
									errors: lastError,
									content: fullContent
								})}\n\n`)
							);
							controller.close();
							return;
						}
					}

					// Validate against schema
					const validation = validateModuleXML(xmlContent);

					if (validation.valid) {
						// Success!
						controller.enqueue(
							encoder.encode(`data: ${JSON.stringify({
								type: 'validation_success',
								message: 'Schema validation passed!'
							})}\n\n`)
						);

						controller.enqueue(
							encoder.encode(`data: ${JSON.stringify({
								type: 'complete',
								message: 'Generation complete',
								content: fullContent,
								xmlContent: xmlContent,
								attempts: attempt,
								warnings: validation.warnings
							})}\n\n`)
						);

						controller.close();
						return;

					} else {
						// Validation failed
						lastError = validation.errors;

						controller.enqueue(
							encoder.encode(`data: ${JSON.stringify({
								type: 'validation_failed',
								message: `Schema validation failed (attempt ${attempt}/${MAX_RETRIES})`,
								errors: validation.errors,
								warnings: validation.warnings
							})}\n\n`)
						);

						if (attempt < MAX_RETRIES) {
							continue; // Retry
						} else {
							// All retries exhausted
							controller.enqueue(
								encoder.encode(`data: ${JSON.stringify({
									type: 'error',
									message: `Schema validation failed after ${MAX_RETRIES} attempts`,
									errors: validation.errors,
									warnings: validation.warnings,
									content: fullContent,
									xmlContent: xmlContent
								})}\n\n`)
							);
							controller.close();
							return;
						}
					}
				}

			} catch (err) {
				const errorMessage = err instanceof Error ? err.message : 'Stream error';
				controller.enqueue(
					encoder.encode(`data: ${JSON.stringify({
						type: 'error',
						message: errorMessage
					})}\n\n`)
				);
				controller.close();
			}
		}
	});

	return new Response(stream, {
		headers: {
			'Content-Type': 'text/event-stream',
			'Cache-Control': 'no-cache',
			'Connection': 'keep-alive'
		}
	});
}

/**
 * Standard JSON response generation (non-streaming) with validation and retry
 */
async function generateModule(body: GenerateRequest, apiKey: string) {
	const MAX_RETRIES = 3;
	let lastError: string[] = [];

	try {
		// Initialize LangChain ChatAnthropic (non-streaming)
		let model = new ChatAnthropic({
			anthropicApiKey: apiKey,
			modelName: 'claude-sonnet-4-5-20250929', // Claude Sonnet 4.5
			temperature: 0.7,
			maxTokens: 16384, // Sonnet 4.5 supports up to 64K output tokens
			timeout: 120000 // 2 minute timeout
		});

		// Conditionally add web search capability
		if (body.enableResearch) {
			model = model.bindTools([{
				type: 'web_search_20250305',
				name: 'web_search',
				max_uses: 5,
				allowed_domains: AI_RESEARCH_DOMAINS
			}]);
		}

		// Retry loop for validation
		for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
			console.log(`Generation attempt ${attempt}/${MAX_RETRIES}`);

			// Build the prompt (include validation errors if retrying)
			const prompt = buildGenerationPrompt(body, attempt > 1 ? lastError : undefined);

			const messages = [
				new SystemMessage('You are an expert curriculum designer. Generate high-quality educational content in valid XML format.'),
				new HumanMessage(prompt)
			];

			// Invoke the model
			const response = await model.invoke(messages);

			// Extract text content (filters out citations and other metadata)
			const textContent = extractTextContent(response.content);

			// Debug logging
			console.log(`Response length: ${textContent.length} characters`);
			console.log(`Response starts with: ${textContent.substring(0, 100)}`);
			console.log(`Response ends with: ${textContent.substring(textContent.length - 100)}`);

			// Extract XML from the clean text
			const xmlContent = extractModuleXML(textContent);

			if (!xmlContent) {
				console.warn('Failed to extract valid XML from response.');
				console.warn('Response length:', textContent.length, 'characters');
				console.warn('First 500 chars:', textContent.substring(0, 500));
				console.warn('Last 500 chars:', textContent.substring(Math.max(0, textContent.length - 500)));

				lastError = [
					'Failed to extract valid XML from response.',
					`Response length: ${textContent.length} characters`,
					'Ensure output is complete with closing </Module> tag.'
				];

				if (attempt < MAX_RETRIES) {
					continue; // Retry
				} else {
					// Last attempt failed
					return json({
						success: false,
						message: 'Failed to generate valid XML after all retry attempts',
						content: textContent,
						xmlContent: null,
						hasValidXML: false,
						validationErrors: lastError,
						attempts: attempt,
						metadata: {
							modelUsed: 'claude-3-5-sonnet-20241022',
							timestamp: new Date().toISOString(),
							enableResearch: body.enableResearch ?? false,
							useExtendedThinking: body.useExtendedThinking ?? false
						}
					});
				}
			}

			// Validate the XML against schema
			console.log('Validating XML against schema...');
			const validation = validateModuleXML(xmlContent);

			if (validation.valid) {
				// Success! Return the valid XML
				console.log('Validation passed');
				return json({
					success: true,
					message: 'Module generated successfully',
					content: textContent, // Full text response (citations filtered out)
					xmlContent: xmlContent, // Extracted and validated XML
					hasValidXML: true,
					validationErrors: [],
					validationWarnings: validation.warnings,
					attempts: attempt,
					metadata: {
						modelUsed: 'claude-3-5-sonnet-20241022',
						timestamp: new Date().toISOString(),
						enableResearch: body.enableResearch ?? false,
						useExtendedThinking: body.useExtendedThinking ?? false
					}
				});
			} else {
				// Validation failed
				console.warn(`Validation failed on attempt ${attempt}:`, validation.errors);
				lastError = validation.errors;

				if (attempt < MAX_RETRIES) {
					// Retry with validation errors
					continue;
				} else {
					// All retries exhausted
					return json({
						success: false,
						message: `Schema validation failed after ${MAX_RETRIES} attempts`,
						content: textContent,
						xmlContent: xmlContent,
						hasValidXML: false,
						validationErrors: validation.errors,
						validationWarnings: validation.warnings,
						attempts: attempt,
						metadata: {
							modelUsed: 'claude-3-5-sonnet-20241022',
							timestamp: new Date().toISOString(),
							enableResearch: body.enableResearch ?? false,
							useExtendedThinking: body.useExtendedThinking ?? false
						}
					});
				}
			}
		}

		// Should not reach here, but just in case
		throw new Error('Unexpected end of retry loop');

	} catch (err) {
		console.error('Generation error:', err);
		throw error(500, {
			message: err instanceof Error ? err.message : 'Failed to generate module'
		});
	}
}
